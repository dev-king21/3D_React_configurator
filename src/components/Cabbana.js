/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { useSnapshot } from "valtio"
import { useFrame } from '@react-three/fiber'
import state from "../state"
import {lengths} from '../utils/constant';
import { Html } from "@react-three/drei";
import * as THREE from 'three'
import { useLoader } from '@react-three/fiber'
import { BsPlusCircle } from "react-icons/bs";

function Blades(props) {
  
  const snap = useSnapshot(state);
  const list = [];
  const texture = useLoader(THREE.TextureLoader, props.texture);
  for (var px = props.x_pos ; px < props.len ; px+=props.x_int ) {
    if (props.isTexture === true) {
      if (snap.blades.rotation === true) {
        list.push(<mesh castShadow receiveShadow geometry={props.blade_geometry} material={props.blade_material}  position={[px - lengths.int_width / 2 + 120, props.y_pos, props.z_pos + lengths.int_depth + 400 ]} rotation={[0, Math.PI / 2, 0]}>
          <meshBasicMaterial attach="material" map={props.isTexture?texture:null} />
        </mesh>
        )          
      }
      else {
        list.push(<mesh castShadow receiveShadow geometry={props.blade_geometry} material={props.blade_material} position={[px, props.y_pos, props.z_pos]}>
          <meshBasicMaterial attach="material" map={props.isTexture?texture:null} />
        </mesh>
        )          
      }
    }
    else {
      if (snap.blades.rotation === true) {
        list.push(<mesh castShadow receiveShadow geometry={props.blade_geometry} material={props.blade_material} position={[px - lengths.int_width / 2 + 120, props.y_pos, props.z_pos + lengths.int_depth + 400 ]} material-color={props.blade_color} rotation={[0, Math.PI / 2, 0]}/>)
      }
      else list.push(<mesh castShadow receiveShadow geometry={props.blade_geometry} material={props.blade_material} position={[px, props.y_pos, props.z_pos]} material-color={props.blade_color} />)
    }
  }
  return list;
}

function Side(props) {
  const snap = useSnapshot(state);
  if (props.current_side === 0) return null;
  switch(props.current_side) {
    case 1:
      return (
      <mesh
        position={[snap.length.width / 2 + lengths.thickness, snap.length.height + lengths.thickness, snap.length.depth/2]}
        rotation={[Math.PI/2, 0, 0]}
      >
        <boxGeometry args={[snap.length.width, snap.length.depth, 1]}/>
        <meshBasicMaterial color="#002853" transparent opacity={0.4}/>
      </mesh>);
    case 2:
      return (
        <mesh
          position={[snap.length.width + lengths.thickness, snap.length.height / 2 + lengths.thickness, snap.length.depth/2]}
          rotation={[Math.PI/2, Math.PI/2, 0]}
        >
          <boxGeometry args={[snap.length.height, snap.length.depth, 1]}/>
          <meshBasicMaterial color="#002853" transparent opacity={0.4}/>
        </mesh>);
      case 3:
      return(
      <mesh
        position={[snap.length.width / 2 + lengths.thickness, lengths.thickness, snap.length.depth/2]}
        rotation={[Math.PI/2, 0, 0]}
      >
        <boxGeometry args={[snap.length.width, snap.length.depth, 1]}/>
        <meshBasicMaterial color="#002853" transparent opacity={0.4}/>
      </mesh>);
    case 4:
      return (
        <mesh
          position={[lengths.thickness, snap.length.height / 2 + lengths.thickness, snap.length.depth/2]}
          rotation={[Math.PI/2, Math.PI/2, 0]}
        >
          <boxGeometry args={[snap.length.height, snap.length.depth, 1]}/>
          <meshBasicMaterial color="#002853" transparent opacity={0.4}/>
        </mesh>);
    default:
      return null;
  }
}
function asciiDif(a,b) {
  return a.charCodeAt(0) - b.charCodeAt(0);
}
export function Model(props) {
  const { nodes, materials } = useGLTF('/cabbana_.glb')

  const blade_geometry = nodes.FBXASC0501_1.geometry;
  const blade_material = materials.Materi03;
  const snap = useSnapshot(state);
  const [currentSide, setCurrentSide] = useState(0);

  const ShiftColumn = (column) => {
    state.columns.editing = true;
    state.columns.editingColumn = column;
    state.columns.added[asciiDif(column, 'A')] = true;
    state.columns.adding = false;
    setCurrentSide(0);
  }

  return (
    <group {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]} position={[-(snap.length.width-lengths.int_width)/2, 0, 0]}>

      <Side current_side = {currentSide} />

      {props.activeStep + props.subStep === 0 ? <Html scaleFactor={5} position={[0, 0, snap.length.depth / 2]}>
          <div className="length-info">{snap.length.depth}mm</div>
      </Html>:null}
      {props.activeStep + props.subStep === 0 ? <Html scaleFactor={5} position={[snap.length.width / 2, 0, snap.length.depth]}>
          <div className="length-info">{snap.length.width}mm</div>
      </Html>:null}
      {props.activeStep + props.subStep === 0 ? <Html scaleFactor={5} position={[0, snap.length.height / 2, snap.length.depth]}>
          <div className="length-info">{snap.length.height}mm</div>
      </Html>:null}


      {props.activeStep === 0 && props.subStep === 1 ? <Html scaleFactor={5} position={[snap.columns.pos[3], 0, snap.length.depth * 3/ 2]}>
          <div className="length-info">D</div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 ? <Html scaleFactor={5} position={[snap.length.width - snap.columns.pos[2], 0, snap.length.depth * 3/ 2]}>
          <div className="length-info">C</div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 ? <Html scaleFactor={5} position={[snap.length.width - snap.columns.pos[1], snap.length.height, snap.length.depth * 3/ 2]}>
          <div className="length-info">B</div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 ? <Html scaleFactor={5} position={[snap.columns.pos[0], snap.length.height, snap.length.depth * 3/ 2]}>
          <div className="length-info">A</div>
      </Html>:null}

      {props.activeStep === 0 && props.subStep === 1 && snap.columns.added[6]? <Html scaleFactor={5} position={[snap.columns.pos[6], 0, snap.length.depth * 3/ 2]}>
          <div className="length-info">G</div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 && snap.columns.added[5]? <Html scaleFactor={5} position={[snap.length.width, snap.length.height - snap.columns.pos[5] + lengths.thickness, snap.length.depth * 3/ 2]}>
          <div className="length-info">F</div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 && snap.columns.added[7]? <Html scaleFactor={5} position={[0, snap.length.height - snap.columns.pos[7] + lengths.thickness, snap.length.depth * 3/ 2]}>
          <div className="length-info">H</div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 && snap.columns.added[4]? <Html scaleFactor={5} position={[snap.columns.pos[4], snap.length.height, snap.length.depth * 3/ 2]}>
          <div className="length-info">E</div>
      </Html>:null}



      {props.activeStep === 0 && props.subStep === 1 && snap.columns.adding === true? <Html scaleFactor={5} position={[snap.length.width / 2, snap.length.height, 0]}>
          <div
            className="side-info"
            onPointerOver={(e) => {if(snap.columns.added[4] === false) setCurrentSide(1)}}
            onPointerOut={(e) => setCurrentSide(0)}
            onClick={(e) => {if(snap.columns.added[4] === false) ShiftColumn('E')}}
          >
            Side 1<BsPlusCircle />
          </div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 && snap.columns.adding === true? <Html scaleFactor={5} position={[snap.length.width, snap.length.height / 2, 0]}>
          <div
            className="side-info"
            onPointerOver={(e) => {if(snap.columns.added[5] === false) setCurrentSide(2)}} 
            onPointerOut={(e) => setCurrentSide(0)}
            onClick={(e) => {if(snap.columns.added[5] === false) ShiftColumn('F')}}
          >
            Side 2<BsPlusCircle />
          </div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 && snap.columns.adding === true? <Html scaleFactor={5} position={[snap.length.width / 2, 0, 0]}>
          <div
            className="side-info"
            onPointerOver={(e) => {if(snap.columns.added[6] === false) setCurrentSide(3)}}
            onPointerOut={(e) => setCurrentSide(0)}
            onClick={(e) => {if(snap.columns.added[6] === false) ShiftColumn('G')}}
          >Side 3<BsPlusCircle />
          </div>
      </Html>:null}
      {props.activeStep === 0 && props.subStep === 1 && snap.columns.adding === true? <Html scaleFactor={5} position={[0, snap.length.height / 2, 0]}>
          <div
            className="side-info"
            onPointerOver={(e) => {if(snap.columns.added[7] === false) setCurrentSide(4)}}
            onPointerOut={(e) => setCurrentSide(0)}
            onClick={(e) => {if(snap.columns.added[7] === false) ShiftColumn('H')}}
          >Side 4<BsPlusCircle />
          </div>
      </Html>:null}



      <group position={[0, 0, snap.length.depth - lengths.int_depth]}>
      <group scale={[1, snap.length.height / lengths.int_height, 1]} position={[0, -lengths.thickness * (snap.length.height/lengths.int_height -1), 1]}>
{/* Right Side*/}
        <mesh castShadow receiveShadow geometry={nodes.FBXASC0497_1.geometry} material={materials.Material}  material-color = {snap.isDesign ? snap.designStyle:snap.structure.color} />
        <mesh castShadow receiveShadow geometry={nodes.FBXASC0576_1.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.Kes_Ekstr6.geometry} material={materials.Material} />
{/* Left Side */}
        <group position={[(snap.length.width - lengths.int_width) * lengths.width_bias, 0, 0]}>
          <mesh castShadow receiveShadow geometry={nodes.FBXASC0496_1.geometry} material={materials.Material} />
          <mesh castShadow receiveShadow geometry={nodes.FBXASC0575_1.geometry} material={materials.Material} />
          <mesh castShadow receiveShadow geometry={nodes.Kes_Ekstr5.geometry} material={materials.Material} />
        </group>        
      </group>

      <group scale={[snap.length.width / lengths.int_width, 1, 1]} position={[ -lengths.thickness * (snap.length.width / lengths.int_width - 1), 0, 0]}>
{/* Front Side */}
      <group position={[0, (snap.length.height-lengths.int_height), 0]}>
        <mesh castShadow receiveShadow geometry={nodes.Group13.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.Group14.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.Group15.geometry} material={materials.Material} />
      </group>

{/* Back Side */}
        <mesh castShadow receiveShadow geometry={nodes.Group20.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.Group21.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.Group22.geometry} material={materials.Material} />
      </group>
      </group>

    <group position={[0, (snap.length.height - lengths.int_height), 0]}>
{/* ColumnA */}
        <group position={[snap.columns.pos[0], 0, 0]}>
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group9.geometry} material={materials.FrontCol}  material-color = {snap.isDesign ? snap.designStyle:snap.structure.color} />
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group10.geometry} material={materials.Material} material-color = {snap.isDesign ? snap.designStyle:snap.structure.color}/>
          <mesh castShadow receiveShadow geometry={nodes.Pah1_2.geometry} material={materials.Materi01} material-color = {snap.isDesign ? snap.designStyle:snap.structure.color}/>
        </group>
        {snap.columns.isShift[4] === true ? 
        <group position={[snap.columns.pos[4], 0, 0]}>
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group9.geometry} material={materials.FrontCol}  material-color = {snap.isDesign ? snap.designStyle:snap.structure.color} />
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group10.geometry} material={materials.Material} material-color = {snap.isDesign ? snap.designStyle:snap.structure.color}/>
          <mesh castShadow receiveShadow geometry={nodes.Pah1_2.geometry} material={materials.Materi01} material-color = {snap.isDesign ? snap.designStyle:snap.structure.color}/>
        </group>:null}
        {snap.columns.isShift[7] === true ? 
        <group position={[0, -snap.columns.pos[7], 0]}>
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group9.geometry} material={materials.FrontCol}  material-color = {snap.isDesign ? snap.designStyle:snap.structure.color} />
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group10.geometry} material={materials.Material} material-color = {snap.isDesign ? snap.designStyle:snap.structure.color}/>
          <mesh castShadow receiveShadow geometry={nodes.Pah1_2.geometry} material={materials.Materi01} material-color = {snap.isDesign ? snap.designStyle:snap.structure.color}/>
        </group>:null}


{/* CornerA */}
      <group position={[0, 0, snap.length.depth - lengths.int_depth]}>
        <mesh castShadow receiveShadow geometry={nodes.Group11.geometry} material={materials.FrontCol} />
        <mesh castShadow receiveShadow geometry={nodes.mesh_92_1.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.mesh_92.geometry} material={materials.Materi01} />
      </group>
{/* ColumnB */}
      <group position={[(snap.length.width - lengths.int_width) * lengths.width_bias, 0, 0]}>
        <group position={[-snap.columns.pos[1], 0, 0]}>
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group5.geometry} material={materials.FrontCol} />
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group6.geometry} material={materials.Material} />
          <mesh castShadow receiveShadow geometry={nodes.Pah10_2.geometry} material={materials.Materi01} />
        </group>
        {snap.columns.isShift[5] === true?
          <group position={[0, -snap.columns.pos[5], 0]}>
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group5.geometry} material={materials.FrontCol} />
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group6.geometry} material={materials.Material} />
          <mesh castShadow receiveShadow geometry={nodes.Pah10_2.geometry} material={materials.Materi01} />
        </group>:null
        }

{/* CornerB */}
        <group position={[0, 0, snap.length.depth - lengths.int_depth]}>
          <mesh castShadow receiveShadow geometry={nodes.Group7.geometry} material={materials.FrontCol} />
          <mesh castShadow receiveShadow geometry={nodes.mesh_100.geometry} material={materials.Material} />
          <mesh castShadow receiveShadow geometry={nodes.mesh_100_1.geometry} material={materials.Materi01} />
        </group>
      </group>
    </group>

{/* ColumnC */}
      <group position={[(snap.length.width - lengths.int_width) * lengths.width_bias, 0, 0]}>
        <group position={[-snap.columns.pos[2], 0, 0]}>
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group24.geometry} material={materials.Material} />
          <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group25.geometry} material={materials.FrontCol} />
          <mesh castShadow receiveShadow geometry={nodes.FBXASC0572_1.geometry} material={materials.Materi02} />
          <mesh castShadow receiveShadow geometry={nodes.Pah1_1.geometry} material={materials.Materi01} />          
        </group>
{/* CornerC */}
        <group position={[0, 0, snap.length.depth - lengths.int_depth]}>
          <mesh castShadow receiveShadow geometry={nodes.Group18.geometry} material={materials.FrontCol} />
          <mesh castShadow receiveShadow geometry={nodes.mesh_76_1.geometry} material={materials.Material} />
          <mesh castShadow receiveShadow geometry={nodes.mesh_76.geometry} material={materials.Materi01} />        
        </group>
      </group>

{/* ColumnD */}
      <group position={[snap.columns.pos[3], 0, 0]}>
        <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group27.geometry} material={materials.FrontCol} />
        <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group28.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.FBXASC0572_2.geometry} material={materials.Materi02} />
        <mesh castShadow receiveShadow geometry={nodes.Pah10_1.geometry} material={materials.Materi01} />
      </group>
      {snap.columns.isShift[6] === true?
        <group position={[snap.columns.pos[6], 0, 0]}>
        <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group27.geometry} material={materials.FrontCol} />
        <mesh castShadow receiveShadow scale={[1, 1, snap.length.depth/lengths.int_depth]} geometry={nodes.Group28.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.FBXASC0572_2.geometry} material={materials.Materi02} />
        <mesh castShadow receiveShadow geometry={nodes.Pah10_1.geometry} material={materials.Materi01} />
      </group>:null
      }

{/* CornerD */}
      <group position={[0, 0, snap.length.depth - lengths.int_depth]}>
        <mesh castShadow receiveShadow geometry={nodes.Group16.geometry} material={materials.FrontCol} />
        <mesh castShadow receiveShadow geometry={nodes.mesh_101.geometry} material={materials.Material} />
        <mesh castShadow receiveShadow geometry={nodes.mesh_101_1.geometry} material={materials.Materi01} />
      </group>
      <group scale={[1, snap.length.height / lengths.int_height, 1]} position={[0, 110*(1 - snap.length.height / lengths.int_height) , snap.length.depth-lengths.int_depth]}>
        <Blades
            blade_geometry={blade_geometry}
            blade_material={blade_material}
            blade_color = {snap.isDesign ? snap.designStyle:snap.blades.color}
            x_pos = {0}
            y_pos = {0}
            z_pos = {0}
            x_int = {200}
            len={snap.length.width}
            isTexture={snap.isTexture}
            texture={snap.blades.texture}
          />        
      </group>

      </group>
    </group>
  )
}

useGLTF.preload('/cabbana_.glb')
